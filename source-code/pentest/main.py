import argparse
import subprocess
import sys
import os
import socket
import requests
from scapy.all import IP, TCP, sr1, sniff
from bs4 import BeautifulSoup
import paramiko # For SSH, but use with caution
import yaml
import json
from reportlab.lib.pagesizes import letter
from reportlab.pdfgen import canvas
# Note: This tool is for AUTHORIZED penetration testing only.
# Ensure you have explicit permission before using on any target.
class PentestTool:
    def __init__(self):
        self.parser = argparse.ArgumentParser(description="HackerOS Pentest Tool")
        self.subparsers = self.parser.add_subparsers(dest="command")
        # Scan command
        scan_parser = self.subparsers.add_parser("scan", help="Perform network scans")
        scan_parser.add_argument("--target", required=True, help="Target IP or hostname")
        scan_parser.add_argument("--type", choices=["port", "vuln"], default="port", help="Scan type")
        scan_parser.add_argument("--ports", default="1-1024", help="Ports to scan")
        # Web command
        web_parser = self.subparsers.add_parser("web", help="Web vulnerability testing")
        web_parser.add_argument("--url", required=True, help="Target URL")
        web_parser.add_argument("--type", choices=["sql", "xss", "crawl"], default="crawl", help="Web test type")
        # Network command
        network_parser = self.subparsers.add_parser("network", help="Network packet analysis")
        network_parser.add_argument("--action", choices=["sniff", "spoof"], required=True, help="Network action")
        network_parser.add_argument("--interface", default="eth0", help="Network interface")
        network_parser.add_argument("--count", type=int, default=10, help="Number of packets")
        network_parser.add_argument("--target", help="Target IP or hostname for spoof")
        # SSH command (for testing, not exploitation)
        ssh_parser = self.subparsers.add_parser("ssh", help="SSH connection test (authorized only)")
        ssh_parser.add_argument("--host", required=True, help="SSH host")
        ssh_parser.add_argument("--user", required=True, help="SSH user")
        ssh_parser.add_argument("--password", help="SSH password (use with caution)")
        # Report command
        report_parser = self.subparsers.add_parser("report", help="Generate report")
        report_parser.add_argument("--data", required=True, help="JSON data for report")
        report_parser.add_argument("--type", choices=["json", "pdf"], default="json", help="Report type")
        report_parser.add_argument("--output", default="report", help="Output file name")
    def run(self):
        if len(sys.argv) == 1:
            self.parser.print_help()
            sys.exit(1)
        args = self.parser.parse_args()
        self.load_policy()
        if args.command == "scan":
            self.perform_scan(args)
        elif args.command == "web":
            self.perform_web_test(args)
        elif args.command == "network":
            self.perform_network_action(args)
        elif args.command == "ssh":
            self.perform_ssh_test(args)
        elif args.command == "report":
            self.generate_report(args)
        else:
            self.parser.print_help()
    def load_policy(self):
        policy_path = os.path.expanduser("~/.hackeros/Security-Mode/policy-security/pentest.yaml")
        if os.path.exists(policy_path):
            with open(policy_path, 'r') as f:
                self.policy = yaml.safe_load(f)
            print("Policy loaded.")
        else:
            print("Warning: No policy file found. Proceeding with defaults.")
            self.policy = {"allow_scans": True, "allow_web": True, "allow_network": True, "allow_ssh": False}
    def check_permission(self, action):
        if not self.policy.get(f"allow_{action}", False):
            print(f"Error: {action} not allowed by policy.")
            sys.exit(1)
    def perform_scan(self, args):
        self.check_permission("scans")
        if args.type == "port":
            print("Performing port scan...")
            result = subprocess.run(['nmap', '-p', args.ports, args.target], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
            print(result.stdout)
            if result.stderr:
                print("Error:", result.stderr)
        elif args.type == "vuln":
            print("Performing vulnerability scan...")
            result = subprocess.run(['nmap', '-sV', '--script', 'vuln', args.target], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
            print(result.stdout)
            if result.stderr:
                print("Error:", result.stderr)
    def perform_web_test(self, args):
        self.check_permission("web")
        if args.type == "crawl":
            response = requests.get(args.url)
            soup = BeautifulSoup(response.text, 'html.parser')
            print("Page title:", soup.title.string)
            print("Links:")
            for link in soup.find_all('a'):
                print(link.get('href'))
        elif args.type == "sql":
            # Simple SQL injection test (educational, not for real use without auth)
            test_payload = "' OR '1'='1"
            response = requests.get(f"{args.url}?id={test_payload}")
            if "error" in response.text.lower() or "sql" in response.text.lower():
                print("Potential SQL vulnerability detected.")
            else:
                print("No obvious SQL error.")
        elif args.type == "xss":
            # Simple XSS test
            test_payload = "<script>alert('xss')</script>"
            response = requests.get(f"{args.url}?q={test_payload}")
            if test_payload in response.text:
                print("Potential XSS vulnerability detected.")
            else:
                print("No reflected XSS found.")
    def perform_network_action(self, args):
        self.check_permission("network")
        if args.action == "sniff":
            packets = sniff(iface=args.interface, count=args.count)
            packets.summary()
        elif args.action == "spoof":
            if not args.target:
                print("Error: --target required for spoof action.")
                sys.exit(1)
            print("Spoofing example (not implemented for safety).")
            # ip = IP(src="spoofed_ip", dst=args.target)
            # syn = TCP(sport=1500, dport=80, flags="S")
            # sr1(ip/syn)
    def perform_ssh_test(self, args):
        self.check_permission("ssh")
        client = paramiko.SSHClient()
        client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        try:
            client.connect(args.host, username=args.user, password=args.password)
            print("SSH connection successful.")
            stdin, stdout, stderr = client.exec_command('ls')
            print(stdout.read().decode())
        except Exception as e:
            print(f"SSH connection failed: {e}")
        finally:
            client.close()
    def generate_report(self, args):
        data = json.loads(args.data)
        if args.type == "json":
            with open(f"{args.output}.json", 'w') as f:
                json.dump(data, f, indent=4)
            print(f"JSON report generated: {args.output}.json")
        elif args.type == "pdf":
            c = canvas.Canvas(f"{args.output}.pdf", pagesize=letter)
            c.drawString(100, 750, "Pentest Report")
            y = 700
            for key, value in data.items():
                c.drawString(100, y, f"{key}: {value}")
                y -= 20
            c.save()
            print(f"PDF report generated: {args.output}.pdf")
if __name__ == "__main__":
    tool = PentestTool()
    tool.run()
